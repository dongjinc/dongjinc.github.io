<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>你不知道的webpack配置</title>
    <link href="/2022/09/04/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84webpack%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/09/04/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84webpack%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>webpack 最出色的功能之一，除了引入 JavaScript 还可以通过 loader 引入任何其他类型的文件。<br>webpack 静态模块打包工具，内部构件一个依赖图.</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><p>4.0 开始，webpack 可以不用在引入一个配置文件来打包项目</p></li><li><p>入口 entry {<br>默认 path -&gt; src&#x2F;index.js<br>数组方式 - [‘src&#x2F;file_1.js’, ‘src&#x2F;file_2.js’] 所谓 “multi-main entry” 一次注入多个依赖文件<br>对象方式 - {<br>dependOn: 当前入口所依赖的入口。它们必须在该入口被加载前被加载<br>}<br>分离 app（应用程序）和 vendor（第三方库入口）<br>entry: {<br>main: ‘src&#x2F;app.js’ ,<br>vendor: ‘src&#x2F;vendor.js’, &#x2F;&#x2F; 存入未作修改的必要 library 或文件（如 jQuery、图片、Bootstrap），然后将它们打包在一起成为单独的 chunk，内容哈希保持不变，从而使浏览器可以独立缓存它们，减少加载时间。<br>}<br>output: ‘[name].[contenthash].bundle.js’<br>webpack &lt; 4 版本中，通过将 vendor 作为单独入口起点添加到 entry 选项中 与 CommonsChunkPlugin 结合使用<br>而在 webpack4 中不鼓励这么做。使用 optimization.splitChunks 选项<br>}</p></li><li><p>loader webpack 只能理解 JavaScript 和 JSON 文件。loader 让 webpack 能够去处理其他类型的文件，并将其转换为有效的模块，以供应用程序使用。<br>1.postcss-loader<br>loader 将会从下面几个地方搜索目录树来寻找配置文件<br>package.json 中的 postcss 属性<br>JSON 或 YAML 格式的.postcssrc 文件<br>.postcss.json、.postcss.yaml、.postcss.yml、.postcss.js 或者 .postcss.cjs 文件<br>postcss.config.js 或者 postcss.config.cjs 导出一个对象的 CommonJS 模块（推荐）</p><p>plugins: [postcss-preset-env, autoprefixer]<br>postcss-preset-env 包含 autoprefixer，注意：使用该插件前提要加 browserslist，在 package.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;browserslist&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>  <span class="hljs-string">&quot;last 1 version&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-string">&quot;&gt; 1%&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-string">&quot;IE 10&quot;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>stage 共分为 5 个阶段，分别是：</p><p>stage-0 非官方草案<br>stage-1 编辑草案或早期工作草案<br>stage-2 工作草案<br>stage-3 候选版本<br>stage-4 推荐标准</p><p>2.加载 images 图像<br>在 webpack5 中使用 Asset Modules，可以将这些内容混入系统中。<br>Asset Modules 资源模块一种模块类型，允许使用资源文件(字体，图标)而无需配置额外 loader<br>在 webpack5 之前，通常使用 raw-loader、url-loader、file-loader<br>资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader<br>asset&#x2F;resource asset&#x2F;inline asset&#x2F;source asset</p></li></ul><p>resource 资源<br>自定义输出文件名<br>output: {<br>assetModuleFilename: ‘images&#x2F;[hash][ext][query]’<br>}</p><p>3.加载字体<br>使用 asset&#x2F;resource</p><p>4.加载数据(csv,tsv,xml)<br>在使用 d3 等工具实现某些数据可视化时，这个功能极其有用。<br>自定义 JSON 模块 parser<br><a href="https://webpack.docschina.org/guides/asset-management/#customize-parser-of-json-modules">https://webpack.docschina.org/guides/asset-management/#customize-parser-of-json-modules</a></p><ul><li><p>管理输出</p><p>1.通过配置 entry,多入口文件时，会生成多个 bundle，不可能一次次手动写入 html 文件内，可借助 HtmlWebpackPlugin 来解决这个文件</p><p>2.HtmlWebpackPlugin 变量、选项配置<br>htmlWebpackPlugin.options.xxx 通过这种方式获取<br>还可以在模板中 获取 webpack definePlugin 定义的环境变量 process.env.NODE_ENV</p><p>3.清理 &#x2F;dist 文件夹<br>1).通过 output:{} clean 选项设置 true 5.20.0+<br>2).借助 clean-webpack-plugin</p></li></ul><p>原理: webpack 和 webpack 插件似乎知道应该生成哪些文件。答案是 webpack 通过 manifest，可以追踪所有模块到输出 bundle 之间的映射 –&gt; manifest<br>manifest 通过 webpack-manifest-plugin 插件打包出来的 manifest.json 文件，用来生成一份资源清单，为后端渲染服务 (要学习<strong>*</strong>)</p><p>webpack5 中，output.publicPath: “auto” ，导致 webpack-manifest-plugin 输出资源带有 auto prefix 字样,通过使用静态 output.publicPath: “” 替代 <a href="https://github.com/shellscape/webpack-manifest-plugin/issues/229">https://github.com/shellscape/webpack-manifest-plugin/issues/229</a></p><ul><li>开发环境 1.使用 source map，当 webpack 打包源代码时，可能会很难追踪到 error(错误)和 warning(警告)<br>例如如果将三个源文件(a.js,b.js,c.js)打包到一个 bundle 中，其中一个源文件包含一个错误，那么堆栈追踪就会直接指向到 bundle.js。可你需要准确地知道错误来源自哪个源文件。<br>为了更容易地追踪 error 和 warning。js 提供了 source maps 功能，可以将编译后的代码映射到原始源代码。如果一个错误来自于 b.js，source map 就会明确的告诉你<br>通过使用 devtool: inline-source-map 选项，获取报错的源文件行数<!-- https://webpack.docschina.org/configuration/devtool/ -->2.开发工具<br>1).webpack’s watch mode<br>2).webpack-dev-server<br>3.webpack-dev-middleware</li></ul><p>使用 watch mode(观察模式)<br>可以指示 webpack”watch”依赖图中所有文件的更改。如果其中一个文件被更新，代码将被重新编译。<br>唯一缺点是：看到修改后的实际效果，需要刷新浏览器。如果能自动刷新浏览器更好，需要通过 webpack-dev-server 实现此功能</p><p>使用 webpack-dev-server 具有 live reloading(实时重新加载功能)<br>webpack-dev-server 会从 output.path 中定义的目录为服务提供 bundle 文件，即，文件将可以通过 http:&#x2F;&#x2F;[devServer.host]:[devServer.port]&#x2F;[output.publicPath]&#x2F;[output.filename] 进行访问。</p><p>webpack-dev-server 在编译之后不会写入到任何输出文件。而是将 bundle 文件保留在内存中，然后将它们 serve 到 server 中，就好像它们是挂载在 server 根路径上的真实文件一样。如果你的页面希望在其他不同路径中找到 bundle 文件，则可以通过 dev server 配置中的 devMiddleware.publicPath 选项进行修改。</p><!-- https://webpack.docschina.org/guides/development/#using-source-maps --><p>如果根据 webpack 官方文档配置到 webpack-dev-server 时，通过 webpack serve –open 命令启动时，浏览器会报错，警告提示，控制台也会有相似错误。1<br>解决办法：<br>1).通过 webpack -&gt; performance:{} hints: false，即可关闭控制台错误和浏览器错误<br>2).通过 webpack -&gt; devServer: {<br>client:{<br>overlay:{<br>error: true &#x2F;&#x2F; 可解决浏览器报错问题<br>}<br>}<br>}</p><!-- https://github.com/webpack/webpack-dev-server/blob/master/migration-v4.md --><p>webpack-dev-server ⚠️：不提供 bundle.js 自动注入，需手动注入<br>通过配置 output: {} 和 devServer: {} 自动注入 bundle.js，如果要开发 react、vue 时，需要使用 HtmlWebpackPlugin 单独提供 public&#x2F;index.html 模版，因为需要在 html 写入 <div id="root"></div></p><p>在 webpack5 中 devServer 配置有过改动，v3 与 v4 有不同<br>新增了 static，去掉了 contentBase<br>static: {<br>directory: ‘’, &#x2F;&#x2F; 基座，告诉服务器从哪里提供内容。<br>publicPath: ‘’ &#x2F;&#x2F; 告诉服务器在哪个 URL 提供 static.directory 的内容<br>}<br>访问地址 http:&#x2F;&#x2F;[devServer.host]:[devServer.port]&#x2F;[static.publicPath]&#x2F;[output.filename]</p><!-- 模块热替换 --><p>官方 dev-server.js config 配置中 plugin 少写了一个 s 导致，还请注意</p><p>1.webpack-dev-middleware 是一个封装器，可以把 webpack 处理过的文件发送到一个 server，webpack-dev-server 在内部使用了它。然而它也可以作为一个单独的 package 来使用，一边根据需求进行更多自定义设置<br>其中 webpack-dev-middleware 并不支持 liveReload，如果要支持 reload 需要借助 webpack-hot-middleware<br>目前官方提供了 webpack-dev-server，由于局限性比较大，单方面对于只提供了使用权限，为了便于扩展性，特此出了 dev-server 和 hot-middleware<br>考虑：1.在使用 webpack-dev-middleware 和 hot-middleware 时，是不是可以扩展微前端<br>2.webpack-dev-middleware 和 hot-middleware 会导致 innerHTML 两次 ？？</p><p>2.HMR 加载样式<br>借助于 style-loader，使用模块热替换来加载 css。主要是因为 loader 幕后使用了 module.hot.accept</p><h2 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h2><ul><li>概述：此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。</li><li>方法：<ul><li>1).<strong>入口起点</strong>：使用 entry 配置手动地分离代码</li><li>2).<strong>使用 entry</strong>：dependencies 或者 splitChunksPlugin 去重和分离 chunk</li><li>3).<strong>动态导入</strong>：通过模块的内联函数调用来分离代码</li></ul></li></ul><h4 id="入口起点"><a href="#入口起点" class="headerlink" title="入口起点"></a>入口起点</h4><ul><li><p>src&#x2F;index.js 和 src&#x2F;another-module.js 共同引入 lodash。会存在一下隐患</p><ul><li>如果入口 chunk 之间包含一些重复模块，那些重复模块都会被引入到各个 bundle 中</li><li>方法不够灵活，不能动态地将核心应用程序、逻辑代码拆分出来</li><li>为了解决以上重复模块问题。</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">entry: &#123;<br>     index: &#123;<br>         import: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>         dependOn: <span class="hljs-string">&#x27;shared&#x27;</span><br>     &#125;,<br>     another:&#123;<br>         import: <span class="hljs-string">&#x27;./src/another-module.js&#x27;</span>,<br>         dependOn: <span class="hljs-string">&#x27;shared&#x27;</span><br>     &#125;,<br>     shared: [<span class="hljs-string">&#x27;lodash&#x27;</span>] <span class="hljs-regexp">//</span> 可以在多个chunk之间共享模块<br> &#125;,<br> &lt;!-- 需要学习下 --&gt;<br> optimization: &#123; <span class="hljs-regexp">//</span> 知识点 一个模块永远不会被多次实例化这很重要。 https:<span class="hljs-regexp">//</span>bundlers.tooling.report<span class="hljs-regexp">/code-splitting/mu</span>lti-entry/<br>     runtimeChunk: <span class="hljs-string">&#x27;multiple&#x27;</span> / <span class="hljs-string">&#x27;single&#x27;</span><br> &#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="splitChunksPlugin"><a href="#splitChunksPlugin" class="headerlink" title="splitChunksPlugin"></a>splitChunksPlugin</h4><ul><li>概述：将公共依赖模块提取到已有的入口 chunk 中，或者提取到一个新生成的 chunk。</li><li>在 webpack v4 之前使用 CommonsChunkPlugin 来避免。目前 webpack v4 以后移除了 CommonsChunkPlugin。取而代之的是 optimization.splitChunks<ul><li>webpack 根据以下条件自动拆分 chunks:<ul><li>新的 chunk 可以被共享，或者模块来自于 node_modules 文件夹</li><li>新的 chunk 体积大于 20kb（在进行 min+gz 之前的体积）</li><li>当按需加载 chunks 时，并行请求的最大数量小于或等于 30</li><li>当加载初始化页面时，并发请求的最大数量小于或等于 30</li></ul></li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">optimization: &#123;<br>       splitChunks: &#123;<br>           chunks: <span class="hljs-string">&#x27;all&#x27;</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><ul><li>移除重复的依赖模块，插件将 load 分离到单独的 chunk，并将其从 main bundle 中移除，减轻大小。mini-css-extract-plugin 用于将 css 从主应用程序中分离</li></ul><h4 id="动态导入"><a href="#动态导入" class="headerlink" title="动态导入"></a>动态导入</h4><ul><li>概述：涉及动态代码拆分时，webpack 提供了两个类似的技术。第一种 import() 第二个 webpack 特定的 require.ensure()</li><li>⚠️：import 调用会在内部用到 promises。如果在旧版浏览器，使用 import，记得使用一个 polyfill 库</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">return</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123;<span class="hljs-keyword">default</span>: _&#125;</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<br>      element.<span class="hljs-property">innerHTML</span> = _.<span class="hljs-title function_">join</span>([<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;webpack&#x27;</span>])<br>      <span class="hljs-keyword">return</span> element<br>  &#125;)<br></code></pre></td></tr></table></figure><h4 id="预获取-x2F-预加载模块-prefetch-x2F-preload-module"><a href="#预获取-x2F-预加载模块-prefetch-x2F-preload-module" class="headerlink" title="预获取&#x2F;预加载模块(prefetch&#x2F;preload module)"></a>预获取&#x2F;预加载模块(prefetch&#x2F;preload module)</h4><ul><li>webpack v4.6.0+ 增加了对预获取和预加载的支持</li><li>prefetch(预获取)：将来某些导航下可能需要的资源</li><li>preload(预加载)：当前导航下可能需要的资源</li></ul><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lisp">import(<span class="hljs-name">/*</span> webpackPrefetch: true */ &#x27;./path/to/LoginModal.js&#x27;);<br><br><br>  if((!__webpack_require__.o(installedChunks, chunkId) || installedChunks[chunkId] === undefined) &amp;&amp; true) &#123;<br>/******/ installedChunks[chunkId] = null;<br>/******/ var link = document.createElement(&#x27;link&#x27;);<br>/******/<br>/******/ if (__webpack_require__.nc) &#123;<br>/******/ link.setAttribute(&quot;nonce&quot;, __webpack_require__.nc);<br>/******/ &#125;<br>/******/ link.rel = &quot;prefetch&quot;;<br>/******/ link.as = &quot;script&quot;;<br>/******/ link.href = __webpack_require__.p + __webpack_require__.u(chunkId);<br>/******/ document.head.appendChild(link);<br>/******/ &#125;<br>&lt;!-- 会生成&lt;link rel=&quot;prefetch&quot; href=&quot;login-modal-chunk.js&quot;&gt; 并追加到页面头部 --&gt;，指示<br></code></pre></td></tr></table></figure><ul><li><p>⚠️：只要父 chunk 完成加载，webpack 就会添加 prefetch hit(预取提示)</p></li><li><p>不同点</p></li><li><p>preload chunk 会在父 chunk 加载时，以并行方式开始加载。prefetch chunk 会在父 chunk 加载结束后开始加载。</p></li><li><p>preload chunk 具有中等优先级，并立即下载。prefetch chunk 在浏览器闲置时下载。</p></li><li><p>preload chunk 会在父 chunk 中立即请求，用于当下时刻。prefetch chunk 会用于未来的某个时刻。<br>浏览器支持程度不同。</p></li></ul><!-- https://www.jiqizhixin.com/articles/2020-07-24-12 --><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul><li>概述：通过 webpack 打包我们模块化后的应用程序，webpack 会生成一个可部署的&#x2F;dist 目录，然后把打包后的内容放置在此目录中。将 dist 文件放在服务器上，用户(client)获取资源时比较耗费资源，由此产生浏览器缓存技术，可降低网络流量，使网站加载速度更快。</li></ul><h4 id="输出文件的文件名"><a href="#输出文件的文件名" class="headerlink" title="输出文件的文件名"></a>输出文件的文件名</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">output: &#123;<br>    filename: <span class="hljs-string">&#x27;[name].[contenthash].bundle.js&#x27;</span>,<br>    path: path.<span class="hljs-built_in">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>    clean: true<br>&#125;,<br>plugins: [<br>    new <span class="hljs-built_in">HtmlWebpackPlugin</span>(&#123;<br>        title: <span class="hljs-string">&#x27;Caching&#x27;</span><br>    &#125;)<br>]<br></code></pre></td></tr></table></figure><ul><li>在老 webpack 版本中，相对于打包出的文件名来说，可能通过配置会有所差异，webpack5.0 会保持一致的 contenthash。官方表明老版本会存在不一致的情况<ul><li>产生原因： webpack 在入口 chunk 中，包含了某些 boilerplate（引导模版），特别是 runtime 和 manifest。(boilerplate 指 webpack 运行时的引导代码)</li></ul></li></ul><h4 id="提取引导模版"><a href="#提取引导模版" class="headerlink" title="提取引导模版"></a>提取引导模版</h4><ul><li>1). 通过 SplitChunksPlugin 可以用于将模块分离到独立的 bundle 中。webpack 还提供了一个优化功能，可以使用 optimization.runtimeChunk 选项将 runtime 代码拆分为一个单独的 chunk。将其设置为 single 来为所有 chunk 创建一个 runtime code</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">optimization: &#123;<br>  runtimeChunk: <span class="hljs-string">&#x27;single&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>将第三方库(library) 提取到单独的 vendor chunk 文件中，比较推荐的做法。这是因为，它们很少像本地的源代码那样频繁修改。通过使用 SplitChunksPlugin 插件的 CacheGroups 选项来实现</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">splitChunks: &#123;<br>  cacheGroups: &#123;<br>    <span class="hljs-comment">&lt;!-- vendor --&gt;</span><br>    vendor: &#123;<br>      test: /[\\/]node_modules[\\/]/,<br>      name: &#x27;vendors&#x27;,<br>      chunks: &#x27;all&#x27;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="模块标识符"><a href="#模块标识符" class="headerlink" title="模块标识符"></a>模块标识符</h4><ul><li>官方例子中新增了 print.js，修改 main 时，期望是指对 main bundle 的 hash 发生变化。<br>官方指出会对第三方的 vendor hash 也会产生变化。在最新的 webpack5.0 中未体现出这样的问题。可能是老版本问题，产生原因：每个 module.id 会默认地基于解析顺序进行增量。当解析顺序发生变化，ID 也会随之改变(module.id)<ul><li>main bundle 会随着自身的新增内容的修改，而发生变化</li><li>vendor bundle 会随着自身的 module.id 的变化，而发生变化</li><li>manifest runtime 会因为现在包含一个新模块的引用，而发生变化</li></ul></li><li>第一个和最后一个符合预期的行为，vendor hash 发生变化是需要修复的。将 optimization.moduleIds 设置为 ‘deterministic’ - 确定性</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">optimization: &#123;<br>  moduleIds: <span class="hljs-string">&#x27;deterministic&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="扩展-TODO-继续研究"><a href="#扩展-TODO-继续研究" class="headerlink" title="扩展 @TODO: 继续研究"></a>扩展 @TODO: 继续研究</h4><ul><li>扩展 cacheGroups 可以单独配置第三方库(由于一个项目内引入第三方库会比较多，导致 vendor 文件大小会特别大，考虑以下几种方式，对 vendor 做拆分处理)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!-- 第一种方式 --&gt;<br>  <span class="hljs-attr">lodash</span>: &#123; <span class="hljs-comment">// 处理第三方库</span><br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]lodash[\\/]/</span>, <span class="hljs-comment">// webpack处理路径时，始终包含Unix系统中的 / 和 Windows系统中 \。 使用[\\/]来表示路径分隔符的原因</span><br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;lodash&#x27;</span>,<br>      <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>,<br>      <span class="hljs-attr">minChunks</span>: <span class="hljs-number">1</span> ,<br>  &#125;,<br>  <span class="hljs-attr">axios</span>: &#123; <span class="hljs-comment">// 处理第三方库</span><br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]axios[\\/]/</span>,<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;axios&#x27;</span>,<br>      <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>,<br>      <span class="hljs-attr">minChunks</span>: <span class="hljs-number">1</span> ,<br>  &#125;<br>&lt;!-- 第二种方式 --&gt;<br>在entry入口配置引入第三方库的名称，来进行打包<br><span class="hljs-attr">splitChunks</span>: &#123;<br>  <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>, <span class="hljs-comment">// 先将 引入模块 拆分出一个bundle</span><br>  <span class="hljs-attr">cacheGroups</span>: &#123;<br>      <span class="hljs-attr">vendors</span>: &#123;<br>          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,<br>          <span class="hljs-comment">// cacheGroupKey here is `commons` as the key of the cacheGroup</span><br>          <span class="hljs-title function_">name</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, chunks, cacheGroupKey</span>) &#123;<br>            <span class="hljs-keyword">const</span> moduleFileName = <span class="hljs-variable language_">module</span><br>              .<span class="hljs-title function_">identifier</span>()<br>              .<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;/&#x27;</span>)<br>              .<span class="hljs-title function_">reduceRight</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item);<br>            <span class="hljs-keyword">const</span> allChunksNames = chunks.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.<span class="hljs-property">name</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;~&#x27;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;cacheGroupKey&#125;</span>-<span class="hljs-subst">$&#123;allChunksNames&#125;</span>-<span class="hljs-subst">$&#123;moduleFileName&#125;</span>`</span>;<br>          &#125;,<br>        &#125;,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>splitChunks.cacheGroups.{cacheGroup}.reuseExistingChunk &#x2F;&#x2F; 如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块</li></ul><h4 id="创建-library-字典-TODO-继续研究"><a href="#创建-library-字典-TODO-继续研究" class="headerlink" title="创建 library(字典) @TODO: 继续研究"></a>创建 library(字典) @TODO: 继续研究</h4><ul><li> 如果打算开发 js 库时，类似 lodash 库都理应安装为 devDependencies,而不是 dependencies。因为我们不需要将其打包到我们的库中，这样我们库的体积会很容易变大</li><li>暴露 library,通过 output.library 配置项暴露入口从而导出内容</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs xml">entry: &#123;<br>      index: &#x27;./src/index.js&#x27;<br>  &#125;,<br>  output: &#123;<br>      path: path.resolve(__dirname, &#x27;dist&#x27;),<br>      filename: &#x27;[name].webpack-numbers.js&#x27;,<br>      clean: true,<br>      library: &#x27;webpackNumbers&#x27;, // 通过library暴露出入口导出的内容<br>  &#125;,<br>  plugins: [<br>      new HtmlWebpackPlugin()<br>  ],<br>  optimization: &#123;<br>      runtimeChunk: &#x27;single&#x27;,<br>      splitChunks: &#123;<br>          chunks: &#x27;all&#x27;,<br>          automaticNameDelimiter: &#x27;~&#x27;<br>      &#125;<br>  &#125;<br><span class="hljs-comment">&lt;!-- 以上会只能通过script标签引用而发挥作用，不能CommonJs、AMD、Nodejs等环境 --&gt;</span><br><span class="hljs-comment">&lt;!-- 解决方式如下 --&gt;</span><br> library: &#123;<br>      name: &#x27;webpackNumbers&#x27;,<br>      type: &#x27;umd&#x27;<br>  &#125;<br>  <span class="hljs-comment">&lt;!-- 注意几个问题 --&gt;</span><br>  通过👆配置：对于<br>  export function xxx()&#123;&#125;<br>  使用时<br>  import xxx from &#x27;xxxx&#x27;<br>  xxx会提示undefined，使用时理应改成 import &#123;xxx&#125; from &#x27;xxxx&#x27; 或者  通过<br>  output: &#123;<br>        library: &#123; // 输入一个库，作为你的入口做导出<br>            name: &#x27;webpackNumbers&#x27;,<br>            export: &#x27;numToWord&#x27;, // __webpack_exports__ = __webpack_exports__.numToWord[export]; 暴露指定方法<br>            type: &#x27;umd&#x27;<br>        &#125;<br>    &#125;<br>  <span class="hljs-comment">&lt;!-- 产生的原因是因为 _xxx__WEBPACK_IMPORTED_MODULE_2__.default，而xxx未导出default --&gt;</span><br></code></pre></td></tr></table></figure><h4 id="外部化-lodash-对于开发库来说，库内有使用其他依赖包时更倾向于把-其他依赖包当作-peerDependency"><a href="#外部化-lodash-对于开发库来说，库内有使用其他依赖包时更倾向于把-其他依赖包当作-peerDependency" class="headerlink" title="外部化 lodash 对于开发库来说，库内有使用其他依赖包时更倾向于把 其他依赖包当作 peerDependency"></a>外部化 lodash 对于开发库来说，库内有使用其他依赖包时更倾向于把 其他依赖包当作 peerDependency</h4><ul><li>1.通过 externals 定义当前包用到的相关库<br>externals: {<br>lodash: {<br>commonjs: ‘lodash’,<br>commonjs2: ‘lodash’,<br>amd: ‘lodash’,<br>root: ‘_‘<br>}<br>}</li><li>拓展 (本地包调试: npm link&#x2F;yarn link)<ul><li>第一步 在开发插件库中 使用 npm link 命令。⚠️:在使用前修改下 package.json 中 name 字段，因为通过 npm link 命令后，会在全局文件生成[packageName]文件夹，其中 packageName 取自插件库 package.json 中 name 字段</li><li> 第二步 使用插件的项目中，使用 npm link [packageName]命令，将会创建一个从全局安装的 packageName 到当前文件内 node_modules 下的符号链接</li><li>第三步 解除 link，在项目中，使用 npm unlink [packageName]。建议将插件库 link 通过 npm unlink 解除掉</li></ul></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> link<span class="hljs-meta"> [packageName]</span><br><span class="hljs-attribute">npm</span> unlink<span class="hljs-meta"> [packageName]</span><br></code></pre></td></tr></table></figure><ul><li>拓展（peerDependencies）<ul><li>开发第三方插件库时，如果依赖了某个第三方包时，比如(lodash),通过设置 peerDependencies 暴露给插件的使用者依赖内需要使用的 lodash 版本号。</li><li>简述：peerDependencies 用来防止多次引入相同的库。对于开发插件来说，都知道使用者一定会提供宿主自身，因此不必在插件库中重复打包安装相同宿主自身。</li><li>🌰：vuex 作为状态管理器，vuex 并没有 dependencies。我们都知道 vuex 一定会依赖 vue。因此 vuex 知道你如果要使用他，就一定会使用 vue。所以他也就不会在 dependencies 中写入。比如 webpack、babel、eslint 等他们的插件都知道使用者一定会提供宿主自身</li><li>开发第三方插件库时，package.json main 字段指向打包后的路径文件地址</li></ul></li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul><li>要想消除 webpack.config.js 在开发环境和生产环境之间的差异。是需要环境变量</li><li>Tips 1.webpack 环境变量与操作系统中的 bash 和 CMD.exe 这些 shell 环境变量不同</li></ul><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mel">webpack命令行 --<span class="hljs-keyword">env</span>参数，可以允许你传入任意数量的环境变量。在webpack.config.js中可以访问到这些环境变量 --<span class="hljs-keyword">env</span> production --<span class="hljs-keyword">env</span> <span class="hljs-keyword">global</span>=local<br>⚠️：如果设置<span class="hljs-keyword">env</span>变量，却没有赋值，--<span class="hljs-keyword">env</span> production默认表示将<span class="hljs-keyword">env</span>.production设置为true<br>⚠️：通常module.exports指向配置对象。要使用<span class="hljs-keyword">env</span>变量，你必须将module.exports转换成一个函数<br><br>module.exports = (<span class="hljs-keyword">env</span>) =&gt; &#123;<br>  console.<span class="hljs-keyword">log</span>(<span class="hljs-keyword">env</span>.production, <span class="hljs-keyword">env</span>) <span class="hljs-comment">//</span><br>  <span class="hljs-keyword">return</span> &#123;<br>      entry: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>      output: &#123;<br>          filename: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>          path: path.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="构建性能"><a href="#构建性能" class="headerlink" title="构建性能"></a>构建性能</h2><h4 id="通用环境"><a href="#通用环境" class="headerlink" title="通用环境"></a>通用环境</h4><ul><li>loader 将应用于最少数量的必须模块。</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">module: &#123;<br>      rules: [<br>          <span class="hljs-regexp">//</span> https:<span class="hljs-regexp">//</span>webpack.docschina.org<span class="hljs-regexp">/loaders/</span>babel-loader/<br>          &#123;<br>              test: <span class="hljs-regexp">/.js$/</span>,<br>              include: path.resolve(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>), <span class="hljs-regexp">//</span> 通过使用include字段，仅将loader应用在实际需要将其转换的模块<br>              loader: <span class="hljs-string">&#x27;babel-loader&#x27;</span> <span class="hljs-regexp">//</span> babel-loader @babel<span class="hljs-regexp">/core @babel/</span>preset-env<br>          &#125;<br>      ]<br>  &#125;<br></code></pre></td></tr></table></figure><ul><li><p>每个额外的 loader&#x2F;plugin 都有其启动时间。尽量地使用工具</p></li><li><p>解析（@TODO: 研究一下）</p><ul><li>减少 resolve.modules、extensions、mainFiles、descriptionFiles 中条目数量，因为他们会增加文件系统调用的次数</li><li>如果不使用 symlinks（例如 npm link 或 yarn link），可以设置 resolve.symlinks: false</li><li>如果使用自定义 resolve plugin 规则，并且没有制定 context 上下文。可以设置 resolve.cacheWithContext: false</li></ul></li><li><p>dll 使用 DllPlugin 为更改不频繁的代码生成单独的编译结果。这可以提供应用程序的编译速度，尽管它增加了构建过程的复杂度（@TODO:）</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">&lt;!-- dllPlugin和dllReferencePlugin --&gt;<br>DllPlugin就是将包含大量复用模块且不频繁更新的库进行编译，只需要编译一次。编译完成后存在指定的文件（这里称为动态链接库）。<br>在之后的构建过程中不会对这些模块进行编译，而是直接使用DllReferencePlugin来引用动态链接库的代码。从而大大提高构建速度<br>⚠️：第一次打包，请先运行dllPlugin生成动态链接库（用于让 DllReferencePlugin 能够映射到相应的依赖上）<br>⚠️：DllPlugin创建动态链接时，需要单独创建一个js文件，用webpack进行输出dll.js和manifest.json文件。一般只针对第三方库而言建议使用DllPlugin。例如react、react-dom、lodash<br>⚠️：在打包项目配置文件中，加入dllReferencePlugin,来引入DllPlugin创建出的manifest.json。打包会输出 delegated（委托）标识符<br>https:<span class="hljs-regexp">//</span>juejin.cn<span class="hljs-regexp">/post/</span><span class="hljs-number">6844903777296728072</span><span class="hljs-comment">#heading-18</span><br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/webpack/</span>webpack<span class="hljs-regexp">/tree/m</span>ain<span class="hljs-regexp">/examples/</span>dll<br></code></pre></td></tr></table></figure><ul><li><p>减少编译结果的整体大小，以提高构建性能。尽量保持 chunk 体积小。</p><ul><li>使用数量更少、体积更小的 library</li><li>在多页面应用程序中使用 SplitChunksPlugin。并开启 async 模式</li><li>移除未引用代码</li><li>只编译你当前正开发的那些代码</li></ul></li><li><p>worker 池（worker pool）<br>thread-loader 可以将非常消耗资源的 loader 分流给一个 worker pool</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs awk">rules: [<br>  <span class="hljs-regexp">//</span> https:<span class="hljs-regexp">//</span>webpack.docschina.org<span class="hljs-regexp">/loaders/</span>babel-loader/<br>  &#123;<br>    test: <span class="hljs-regexp">/\.js$/</span>,<br>    include: path.resolve(__dirname, <span class="hljs-string">&quot;src&quot;</span>), <span class="hljs-regexp">//</span> 通过使用include字段，仅将loader应用在实际需要将其转换的模块<br>    use: [<br>        <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;thread-loader&#x27;</span>, 如果小项目，文件不多无需开启多进程打包，反而会变慢，因为开启进程时需要花费时间的。<br>        &#123;<br>            loader: <span class="hljs-string">&#x27;babel-loader&#x27;</span>, <span class="hljs-regexp">//</span> babel-loader @babel<span class="hljs-regexp">/core @babel/</span>preset-env<br>            options: &#123;<br>              presets: [<br>                [<br>                  <span class="hljs-string">&quot;@babel/preset-env&quot;</span>,<br>                  &#123;<br>                    useBuiltIns: <span class="hljs-string">&quot;entry&quot;</span>,<br>                    targets: &#123; chrome: <span class="hljs-string">&quot;68&quot;</span> &#125;, <span class="hljs-regexp">//</span> 通过targets 控制包输出的结果是否兼容对应目标浏览器<br>                  &#125;,<br>                ],<br>              ],<br>            &#125;,<br>          &#125;<br>    ],<br>  &#125;,<br>]<br><br></code></pre></td></tr></table></figure><ul><li>webpack cache（持久化） @TODO: 非常棒的功能</li></ul><h4 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h4><p><a href="https://webpack.docschina.org/guides/build-performance/">https://webpack.docschina.org/guides/build-performance/</a></p><h2 id="增量编译"><a href="#增量编译" class="headerlink" title="增量编译"></a>增量编译</h2><ul><li>使用 webpack 的 watch mode（监听模式），而不使用其他工具来 watch 文件和调用 webpack. watch mode 会记录时间戳并将此信息传递给 compilation 以使缓存失效</li><li>watch mode 会回退到 pull mode（轮询模式）。监听许多文件会导致 CPU 大量负载。可通过 watchOptions.poll 来增加轮询的间隔时间</li></ul><h2 id="在内存中编译"><a href="#在内存中编译" class="headerlink" title="在内存中编译"></a>在内存中编译</h2><ul><li>webpack-dev-server</li><li>webpack-hot-middleware</li><li>webpack-dev-middleware</li></ul><h2 id="stats-toJson-加速-最小化每个增量构建步骤中，从-stats-对象获取的数据量-TODO"><a href="#stats-toJson-加速-最小化每个增量构建步骤中，从-stats-对象获取的数据量-TODO" class="headerlink" title="stats.toJson 加速 最小化每个增量构建步骤中，从 stats 对象获取的数据量 @TODO:"></a>stats.toJson 加速 最小化每个增量构建步骤中，从 stats 对象获取的数据量 @TODO:</h2><h2 id="Devtool"><a href="#Devtool" class="headerlink" title="Devtool"></a>Devtool</h2><ul><li>“eval”具有最好的性能，但不能帮助转译代码。</li><li>最佳选择 eval-cheap-module-source-map</li></ul><h2 id="避免在生产环境下才会用到的工具"><a href="#避免在生产环境下才会用到的工具" class="headerlink" title="避免在生产环境下才会用到的工具"></a>避免在生产环境下才会用到的工具</h2><ul><li>某些 utility、plugin 和 loader 都只用于生产环境。如开发环境下使用 TerserPlugin 来 minify(压缩)和 mangle(混淆破坏)代码是没有意义的。</li></ul><h2 id="最小化-entry-chunk"><a href="#最小化-entry-chunk" class="headerlink" title="最小化 entry chunk"></a>最小化 entry chunk</h2><ul><li>webpack 只会在文件系统中输出已更新的 chunk，对于 output.chunkFileName 的[name]&#x2F;[chunkhash]&#x2F;[contenthash]&#x2F;[fullhash]来说，对已经更新的 chunk 无效之外，对于 entry chunk 也不会生效。<br>确保生成 entry chunk 时，尽量减少其体积以提高性能。为运行时代码创建了一个额外的 chunk。</li><li>runtimeChunk 将包含 chunks 映射关系的 list 单独从主包中提取出来。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">optimization</span>: &#123;<br>    <span class="hljs-attr">runtimeChunk</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="避免额外的优化步骤"><a href="#避免额外的优化步骤" class="headerlink" title="避免额外的优化步骤"></a>避免额外的优化步骤</h2><ul><li>webpack 通过执行额外的算法任务，来优化输出结果的体积和加载性能。</li><li>比如：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">optimization</span>: &#123;<br>    <span class="hljs-attr">removeAvailableModules</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">removeEmptyChunks</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">splitChunks</span>: <span class="hljs-literal">false</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="typescript-loader"><a href="#typescript-loader" class="headerlink" title="typescript loader"></a>typescript loader</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.tsx?$/</span>,<br>  <span class="hljs-attr">use</span>: [<br>    &#123;<br>      <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;ts-loader&quot;</span>,<br>      <span class="hljs-attr">options</span>: &#123;<br>        <span class="hljs-attr">transpileOnly</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 传入transpileOnly选项，以缩短使用ts-loader时的构建时间。</span><br>      &#125;,<br>    &#125;,<br>  ],<br>&#125;;<br><span class="hljs-comment">// ⚠️：使用此选项，会关闭类型检查。通过使用ForkTsCheckerWebpackPlugin。该插件会将检查过程移至单独的进程，可以加快ts类型检查和eslint插入的速度</span><br><span class="hljs-comment">// https://github.com/TypeStrong/ts-loader/tree/master/examples/fork-ts-checker-webpack-plugin</span><br></code></pre></td></tr></table></figure><h4 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h4><h2 id="commonjs"><a href="#commonjs" class="headerlink" title="commonjs"></a>commonjs</h2><ul><li>如果 require 含有表达式，就会创建一个上下文哦</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">example_directory<br>│<br>└───template<br>│   │   table.ejs<br>│   │   table-row.ejs<br>│   │<br>│   └───directory<br>│       │   another.ejs<br>require调用被评估解析 - require(&#x27;./template/&#x27; + name + &#x27;.ejs&#x27;)<br></code></pre></td></tr></table></figure><ul><li>webpack 解析 require()调用，会提取如以下信息</li><li>Directory: .&#x2F;template Regular expression: &#x2F;^.*.ejs$&#x2F;</li><li>context module 生成一个 context module（上下文模块）。包含目录下所有模块的引用<br>如果一个 request 符合正则表达式，就能 require 进来。</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs armasm">映射<br>&#123;<br>  <span class="hljs-string">&quot;./table.ejs&quot;</span>: <span class="hljs-number">42</span>,<br>  <span class="hljs-string">&quot;./table-row.ejs&quot;</span>: <span class="hljs-number">43</span>,<br>  <span class="hljs-string">&quot;./directory/another.ejs&quot;</span>: <span class="hljs-number">44</span><br>&#125;<br>这意味着webpack能够支持动态<span class="hljs-meta">require</span>,但会导致所有可能用到的模块都包含在bundle中<br>⚠️：打包出来的webpack文件内部会有一个<span class="hljs-meta">map</span>映射，<br></code></pre></td></tr></table></figure><h2 id="require-context"><a href="#require-context" class="headerlink" title="require.context"></a>require.context</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 参数一 指定目录</span><br><span class="hljs-comment"> * 参数二 是否还搜索其子目录</span><br><span class="hljs-comment"> * 参数三 表达匹配文件表达式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">require</span>.<span class="hljs-title function_">context</span>(<span class="hljs-string">&quot;./component/&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-regexp">/\.js$/</span>));<br><span class="hljs-comment">// 创建出一个context,其中文件来自test目录，request以 .js 结尾</span><br></code></pre></td></tr></table></figure><ul><li>api -&gt; resolve 是一个函数，它返回 request 被解析后得到的模块 id</li><li>api -&gt; keys 是一个函数，返回一个数组。</li><li>api -&gt; id 是 context module 的模块 id. 在使用 module.hot.accept 会用到</li></ul><h4 id="Tree-shaking"><a href="#Tree-shaking" class="headerlink" title="Tree shaking"></a>Tree shaking</h4><ul><li><p>通过用于描述移除 js 上下文中未引用代码(dead-code)。它依赖于<br>es5 模块的静态结构特性，例如 import 和 export</p></li><li><p>动态结构特性</p></li><li><p>对于动态结构来说，导入和导出可以在运行时更改。</p></li><li><p>静态结构特性</p></li><li><p>对于静态结构来说，编译时(静态地)确定导入和导出。只需要查看源代码，而不必执行它</p></li><li><p>es6 语法上强制执行，您只能在顶层导入和导出（永远不要嵌套在条件语句中）</p></li><li><p>import 和 export 语句没有动态部分（不允许使用变量）</p></li><li><p>好处</p></li><li><p>1.捆绑期间的死代码消除</p></li><li><p>在前端开发中，模块通常这样处理</p><ul><li>在开发过程代码存在许多模块，通常是小模块</li><li>对于部署，这些模块被捆绑到几个相对较大的文件中。</li></ul></li><li><p>捆绑原因</p><ul><li>为了加载所有模块，需要检索的文件更少</li><li>压缩捆绑的文件比压缩单独的文件会更有效</li><li>捆绑期间，可以删除未使用的导出，节省空间</li></ul></li><li><p>原因 1 在 http&#x2F;1 很重要，请求文件的成本相对较高。随着 http&#x2F;2 而改变，便显得无关紧要</p></li><li><p>原因 3 通过具有静态结构的模块格式化实现</p></li><li><p>es6 模块特性</p><ul><li>1.它们的静态结构意味着捆绑格式不必考虑有条件加载的模块。(对于 vue&#x2F;组件可以有条件或按需导入模块是因为使用了编程加载器 API)</li><li>2.导入是导出的制度视图，意味着您不必复制导出，可以直接引用它们。</li></ul></li><li><p>2.更快地查找导入</p><ul><li>如果你需要一个 commonjs 库，会得到一个对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> lib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lib)</span><br><span class="hljs-string">lib.someFunc()</span><br><span class="hljs-string">// 通过访问命名导出lib.someFunc意味着您必须进行属性查找，这很慢。因为是动态的</span><br><span class="hljs-string">// 相反，在es6中导入一个库，静态地知道它的内容并且可以优化访问</span><br><span class="hljs-string">import * as lib from &#x27;</span>lib<span class="hljs-string">&#x27;</span><br><span class="hljs-string">lib.someFunc()</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>3.同时支持同步和异步加载</p></li><li><p>es6 模块必须独立于引擎是同步加载模块（例如在服务器上）还是异步加载模块（例如浏览器中）。<br>它的语法非常适合同步加载，异步加载由其静态结构启用。因为可以静态确定所有导入。可以在评估模块主体之前加载它们（类似 AMD）</p></li><li><p>4.准备好使用宏。TODO:</p></li><li><p>5.变量检查</p><ul><li>使用静态模块结构，始终可以静态地知道哪些变量在模块内任何位置可见</li><li>对于检查给定的标识符是否拼写正确非常有帮助。这种检查是 jsLint 和 jsHint 等 linter 的流行特性</li><li>lib.foo 还可以静态检查命名导入（提示）</li></ul></li><li><p>6.支持模块之间的循环依赖 TODO:</p><!-- https://exploringjs.com/es6/ch_modules.html#static-module-structure --></li></ul><h2 id="常见模块问题"><a href="#常见模块问题" class="headerlink" title="常见模块问题"></a>常见模块问题</h2><ul><li>1.使用一个变量来指定我想从哪个模块导入<ul><li>由于 import 语句完全静态，它的模块说明符始终是固定。如果要动态确定要加载的模块，需要使用程序化加载器 API<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleSpecifier = <span class="hljs-string">&quot;module_&quot;</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>();<br><span class="hljs-title class_">System</span>.<span class="hljs-title function_">import</span>(moduleSpecifier).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) =&gt;</span> &#123;&#125;);<br></code></pre></td></tr></table></figure></li></ul></li><li>2.有条件地或按需导入模块<ul><li>导入语句必须位于模块的顶层。意味着您不能将它们嵌套在 if 语句、函数等。如果有条件地或按需加载模块，就必须使用编程加载器 API<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()) &#123;<br>  <span class="hljs-title class_">System</span>.<span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;some_module&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) =&gt;</span> &#123;&#125;);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>3.是否可以在 import 语句中使用变量吗<ul><li>不能。导入的内容不得依赖于在运行时计算任何内容。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;some_module&#x27;</span> + <span class="hljs-variable constant_">SUFFIX</span><br></code></pre></td></tr></table></figure></li></ul></li><li>4.可以在 import 语句中使用解构吗</li><li>不能</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;<span class="hljs-attr">foo</span>: &#123;bar&#125;&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;some_module&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h4><ul><li>PurgeCSSPlugin 对未使用 css 进行删除 <a href="https://github.com/FullHuman/purgecss/tree/main/packages/purgecss-webpack-plugin">https://github.com/FullHuman/purgecss/tree/main/packages/purgecss-webpack-plugin</a></li><li>Webpack Deep Scope Analysis Plugin 目前 webpack5 已支持 <a href="https://github.com/vincentdchan/webpack-deep-scope-analysis-plugin">https://github.com/vincentdchan/webpack-deep-scope-analysis-plugin</a></li></ul><h4 id="package"><a href="#package" class="headerlink" title="package"></a>package</h4><ul><li>yargs-parser 命令行交互工具 <a href="http://yargs.js.org/">http://yargs.js.org/</a></li></ul><h4 id="FIS3"><a href="#FIS3" class="headerlink" title="FIS3"></a>FIS3</h4><p>1.微前端 如何</p><ul><li><p>webpack 打包进度条<br>webpackbar<br>progress-bar-webpack-plugin</p></li><li><p>plugin 打包优化、资源管理，注入环境变量</p></li><li><p>了解下 source-map<br>webpack 指南</p></li><li><p>管理资源<br>1). 加载 css - loader style-loader、css-loader 自下往上执行-从右往左 - plugin mini-css-extract-plugin(提取 css)、css-minimizer-webpack-plugin(压缩 css)</p><pre><code class="hljs"> optimization: &#123;     minimizer: [     ] &#125;</code></pre></li></ul><!-- https://segmentfault.com/a/1190000023734704 --><p>npm info webpack 查看 webpack 版本<br>nrm 管理 npm 源<br>nrm ls 查看有哪些源(镜像)可以使用<br>nrm use xxx<br>nrm test</p><p>path.resolve() 两个相对路径变成绝对路径</p><p>file-loader 1.发现图片模块 2.打包到 dist 目录下，改名字，自定义 3.移动到 dist 目录下后，得到图片的名称 4.返回使用图片名称<br>npm webpack –config webpack.config.js</p><h2 id="resolve-解析"><a href="#resolve-解析" class="headerlink" title="resolve 解析"></a>resolve 解析</h2><p>该选项能设置模块如何被解析。webpack 提供合理的默认值<br>模块解析(module resolution)<br>resolver 是一个帮助寻找模块绝对路径的库。一个模块可以作为另一个模块的依赖模块。然后被后者引用<br>所依赖模块可以应用程序的代码或第三方库。resolver 帮助 webpack 从每个 require&#x2F;import 语句中。找到需要的 bundle<br>webpack 使用 enhanced-resolve 来解析文件路径</p><p>webpack 中的解析规则 1.绝对路径<br>import ‘&#x2F;home&#x2F;me&#x2F;file’<br>已获得文件的绝对路径，因此不需要再做进一步解析</p><p>2.相对路径<br>import ‘..&#x2F;src&#x2F;file1’<br>使用 import 或 require 的资源文件所处的目录，被认为上下文目录。在 import&#x2F;require 中给定的相对路径，拼接上下文路径</p><p>3.模块路径<br>resolve.modules 中指定所有目录检索模块。通过 resolve.alias 别名方式来替换初始模块路径。<br>1。如果 package 中包含 package.json 文件，那么在 resolve.exportsFields 配置选项中指定字段会被依次查找。通过 package.json main 字段确定 package 可用的 export<br>2.resolver 将会检查路径是指向文件还是文件夹。<br>如果文件的扩展名被包含在 resolve.extensions 项内，可直接将其打包，否则通过配置该项告诉解析器在解析中能够接受哪些扩展名</p><h2 id="相关-loader"><a href="#相关-loader" class="headerlink" title="相关 loader"></a>相关 loader</h2><ul><li>less-loader</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"> &#123;<br>  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.less$/</span>,<br>  <span class="hljs-attr">use</span>: [<br>    <span class="hljs-string">&quot;style-loader&quot;</span>,<br>    <span class="hljs-string">&quot;css-loader&quot;</span>,<br>    &#123;<br>      <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;less-loader&quot;</span>,<br>      <span class="hljs-attr">options</span>: &#123;<br>        <span class="hljs-attr">lessOptions</span>: &#123;<br>          <span class="hljs-attr">globalVars</span>: &#123; <span class="hljs-comment">// 这个选项定义了一个可以被文件引用的变量。 实际上，声明被放置在你的基础 Less 文件的顶部，这意味着它可以被使用，但如果在文件中定义了这个变量，它也可以被覆盖。</span><br>            <span class="hljs-attr">var1</span>: <span class="hljs-string">&quot;yellow&quot;</span>,<br>            <span class="hljs-attr">var2</span>: <span class="hljs-string">&quot;regular value&quot;</span>,<br>          &#125;,<br>          <span class="hljs-attr">modifyVars</span>: &#123; <span class="hljs-comment">// 与全局变量选项相反，这将声明放在基本文件的末尾，这意味着它将覆盖您的 Less 文件中定义的任何内容。</span><br>            <span class="hljs-attr">var1</span>: <span class="hljs-string">&quot;yellow&quot;</span><br>          &#125;<br>        &#125;,<br>      &#125;,<br>    &#125;,<br>  ],<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h2><ul><li>webpack配置host为0.0.0.0时，怎么让服务启动时打开127.0.0.1页面<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">open</span>: <span class="hljs-string">&#x27;http://127.0.0.1:8888&#x27;</span>, <span class="hljs-comment">// boolean / string</span><br>  <span class="hljs-attr">port</span>: <span class="hljs-number">8888</span>,<br>  <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;0.0.0.0&#x27;</span>,<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>git push origin –delete main<br>git -vv<br>find .git&#x2F;refs<br>git remote set-head origin master</p><p><a href="https://github.com/kaola-fed/blog/issues/238">https://github.com/kaola-fed/blog/issues/238</a></p><p><a href="http://jartto.wang/2018/12/11/git-rebase/">http://jartto.wang/2018/12/11/git-rebase/</a></p><p><a href="https://segmentfault.com/a/1190000005614604?_ea=868190">https://segmentfault.com/a/1190000005614604?_ea=868190</a><br><a href="https://www.zoo.team/article/webpack">https://www.zoo.team/article/webpack</a></p><p>研究 1.git rebase 和 git merge 区别</p><p>git rebase<br>1).可以对提交的 commit 进行合并，整理 commit 提交历史<br>2).合并其他分支。<br>例如：<br>git checkout experiment<br>git rebase master</p><p>原理：首先找到这两个分支，即当前分支 experiment、变基操作的目标基底分支 master 的最近共同祖先 C2.对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件</p><p>研究 2.https 和 ssh<br>ssh -p3000 <a href="mailto:&#x72;&#x6f;&#x6f;&#116;&#x40;&#49;&#x34;&#x2e;&#x31;&#x37;&#x2e;&#50;&#x32;&#46;&#x33;&#x32;">&#x72;&#x6f;&#x6f;&#116;&#x40;&#49;&#x34;&#x2e;&#x31;&#x37;&#x2e;&#50;&#x32;&#46;&#x33;&#x32;</a></p><p>文档书籍 <a href="https://exploringjs.com/es6/index.html#toc_ch_modules">https://exploringjs.com/es6/index.html#toc_ch_modules</a></p><p>未来规划 -&gt;<br>http、https<br>微前端</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo部署</title>
    <link href="/2022/09/04/hello-world/"/>
    <url>/2022/09/04/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
